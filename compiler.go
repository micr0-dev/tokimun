package main

import (
	"fmt"
	"regexp"
	"strings"
)

type Compiler struct {
	tokens         []Token
	current        int
	output         strings.Builder
	indent         int
	scopes         []map[string]bool // Track declared variables per scope
	loopDepth      int               // Track nested loops for continue
	continueLabels []int             // Unique labels for continue
	labelCounter   int
	switchDepth    int  // Track nested switches
	noMethodCalls  bool // Disable method call parsing (for case expressions)
}

func NewCompiler(tokens []Token) *Compiler {
	return &Compiler{
		tokens:         tokens,
		current:        0,
		indent:         0,
		scopes:         []map[string]bool{make(map[string]bool)},
		loopDepth:      0,
		continueLabels: []int{},
		labelCounter:   0,
	}
}

func (c *Compiler) Compile() (string, error) {
	c.output.WriteString("-- Generated by tokimun v0.1\n")
	c.output.WriteString("-- https://github.com/tokimun\n\n")

	for !c.isAtEnd() {
		if err := c.statement(); err != nil {
			return "", err
		}
	}

	return c.output.String(), nil
}

func (c *Compiler) statement() error {
	switch c.peek().Type {
	case TOKEN_GLOBAL:
		return c.globalDeclaration()
	case TOKEN_LOCAL:
		return c.localDeclaration()
	case TOKEN_FUNCTION:
		return c.functionDeclaration()
	case TOKEN_IF:
		return c.ifStatement()
	case TOKEN_WHILE:
		return c.whileStatement()
	case TOKEN_FOR:
		return c.forStatement()
	case TOKEN_REPEAT:
		return c.repeatStatement()
	case TOKEN_DO:
		return c.doStatement()
	case TOKEN_RETURN:
		return c.returnStatement()
	case TOKEN_BREAK:
		return c.breakStatement()
	case TOKEN_CONTINUE:
		return c.continueStatement()
	case TOKEN_GOTO:
		return c.gotoStatement()
	case TOKEN_DOUBLECOLON:
		return c.labelStatement()
	case TOKEN_SWITCH:
		return c.switchStatement()
	case TOKEN_EOF:
		return nil
	default:
		return c.expressionStatement()
	}
}

func (c *Compiler) globalDeclaration() error {
	c.advance() // consume 'global'

	if c.peek().Type != TOKEN_IDENT {
		return fmt.Errorf("line %d: expected identifier after 'global'", c.peek().Line)
	}

	name := c.advance().Value

	if c.peek().Type == TOKEN_ASSIGN {
		c.advance() // consume '='
		c.writeIndent()
		c.output.WriteString(name)
		c.output.WriteString(" = ")
		if err := c.expression(); err != nil {
			return err
		}
		c.output.WriteString("\n")
	} else {
		// Just declare as global (in Lua, we don't need to do anything special)
		c.writeIndent()
		c.output.WriteString(name)
		c.output.WriteString(" = nil\n")
	}

	return nil
}

func (c *Compiler) localDeclaration() error {
	c.advance() // consume 'local'

	if c.peek().Type == TOKEN_FUNCTION {
		return c.localFunctionDeclaration()
	}

	if c.peek().Type != TOKEN_IDENT {
		return fmt.Errorf("line %d: expected identifier after 'local'", c.peek().Line)
	}

	c.writeIndent()
	c.output.WriteString("local ")

	// Handle multiple declarations: local a, b, c = 1, 2, 3
	names := []string{}
	for {
		if c.peek().Type != TOKEN_IDENT {
			return fmt.Errorf("line %d: expected identifier", c.peek().Line)
		}
		name := c.advance().Value
		names = append(names, name)
		c.declareVariable(name)

		if c.peek().Type != TOKEN_COMMA {
			break
		}
		c.advance() // consume ','
	}

	c.output.WriteString(strings.Join(names, ", "))

	if c.peek().Type == TOKEN_ASSIGN {
		c.advance() // consume '='
		c.output.WriteString(" = ")
		if err := c.expressionList(); err != nil {
			return err
		}
	}
	c.output.WriteString("\n")

	return nil
}

func (c *Compiler) localFunctionDeclaration() error {
	c.advance() // consume 'function'

	if c.peek().Type != TOKEN_IDENT {
		return fmt.Errorf("line %d: expected function name", c.peek().Line)
	}

	name := c.advance().Value
	c.declareVariable(name)

	c.writeIndent()
	c.output.WriteString("local function ")
	c.output.WriteString(name)

	return c.functionBody()
}

func (c *Compiler) functionDeclaration() error {
	c.advance() // consume 'function'

	c.writeIndent()
	c.output.WriteString("local function ")

	// Function name (can be dotted: foo.bar.baz)
	if c.peek().Type != TOKEN_IDENT {
		return fmt.Errorf("line %d: expected function name", c.peek().Line)
	}

	name := c.advance().Value
	c.output.WriteString(name)
	c.declareVariable(name)

	// Handle method syntax: function foo:bar()
	for c.peek().Type == TOKEN_DOT || c.peek().Type == TOKEN_COLON {
		c.output.WriteString(c.advance().Value)
		if c.peek().Type != TOKEN_IDENT {
			return fmt.Errorf("line %d: expected identifier after '.' or ':'", c.peek().Line)
		}
		c.output.WriteString(c.advance().Value)
	}

	return c.functionBody()
}

func (c *Compiler) functionBody() error {
	if c.peek().Type != TOKEN_LPAREN {
		return fmt.Errorf("line %d: expected '(' after function name", c.peek().Line)
	}
	c.advance()
	c.output.WriteString("(")

	c.pushScope()

	// Parameters
	first := true
	for c.peek().Type != TOKEN_RPAREN && !c.isAtEnd() {
		if !first {
			c.output.WriteString(", ")
		}
		first = false

		if c.peek().Type == TOKEN_DOTDOTDOT {
			c.advance()
			c.output.WriteString("...")
		} else if c.peek().Type == TOKEN_IDENT {
			name := c.advance().Value
			c.output.WriteString(name)
			c.declareVariable(name)
		} else {
			return fmt.Errorf("line %d: expected parameter name", c.peek().Line)
		}

		if c.peek().Type == TOKEN_COMMA {
			c.advance()
		}
	}

	if c.peek().Type != TOKEN_RPAREN {
		return fmt.Errorf("line %d: expected ')' after parameters", c.peek().Line)
	}
	c.advance()
	c.output.WriteString(")\n")

	c.indent++

	// Function body
	for c.peek().Type != TOKEN_END && !c.isAtEnd() {
		if err := c.statement(); err != nil {
			return err
		}
	}

	c.indent--
	c.popScope()

	if c.peek().Type != TOKEN_END {
		return fmt.Errorf("line %d: expected 'end' to close function", c.peek().Line)
	}
	c.advance()

	c.writeIndent()
	c.output.WriteString("end\n")

	return nil
}

func (c *Compiler) ifStatement() error {
	c.advance() // consume 'if'

	c.writeIndent()
	c.output.WriteString("if ")

	if err := c.expression(); err != nil {
		return err
	}

	if c.peek().Type != TOKEN_THEN {
		return fmt.Errorf("line %d: expected 'then' after if condition", c.peek().Line)
	}
	c.advance()
	c.output.WriteString(" then\n")

	c.indent++
	c.pushScope()

	for c.peek().Type != TOKEN_END && c.peek().Type != TOKEN_ELSE && c.peek().Type != TOKEN_ELSEIF && !c.isAtEnd() {
		if err := c.statement(); err != nil {
			return err
		}
	}

	c.popScope()
	c.indent--

	// Handle elseif and else
	for c.peek().Type == TOKEN_ELSEIF {
		c.advance()
		c.writeIndent()
		c.output.WriteString("elseif ")

		if err := c.expression(); err != nil {
			return err
		}

		if c.peek().Type != TOKEN_THEN {
			return fmt.Errorf("line %d: expected 'then' after elseif condition", c.peek().Line)
		}
		c.advance()
		c.output.WriteString(" then\n")

		c.indent++
		c.pushScope()

		for c.peek().Type != TOKEN_END && c.peek().Type != TOKEN_ELSE && c.peek().Type != TOKEN_ELSEIF && !c.isAtEnd() {
			if err := c.statement(); err != nil {
				return err
			}
		}

		c.popScope()
		c.indent--
	}

	if c.peek().Type == TOKEN_ELSE {
		c.advance()
		c.writeIndent()
		c.output.WriteString("else\n")

		c.indent++
		c.pushScope()

		for c.peek().Type != TOKEN_END && !c.isAtEnd() {
			if err := c.statement(); err != nil {
				return err
			}
		}

		c.popScope()
		c.indent--
	}

	if c.peek().Type != TOKEN_END {
		return fmt.Errorf("line %d: expected 'end' to close if statement", c.peek().Line)
	}
	c.advance()

	c.writeIndent()
	c.output.WriteString("end\n")

	return nil
}

func (c *Compiler) whileStatement() error {
	c.advance() // consume 'while'

	c.labelCounter++
	label := c.labelCounter
	c.continueLabels = append(c.continueLabels, label)
	c.loopDepth++

	c.writeIndent()
	c.output.WriteString("while ")

	if err := c.expression(); err != nil {
		return err
	}

	if c.peek().Type != TOKEN_DO {
		return fmt.Errorf("line %d: expected 'do' after while condition", c.peek().Line)
	}
	c.advance()
	c.output.WriteString(" do\n")

	c.indent++
	c.pushScope()

	for c.peek().Type != TOKEN_END && !c.isAtEnd() {
		if err := c.statement(); err != nil {
			return err
		}
	}

	// Add continue label before end
	c.writeIndent()
	c.output.WriteString(fmt.Sprintf("::__continue_%d__::\n", label))

	c.popScope()
	c.indent--
	c.loopDepth--
	c.continueLabels = c.continueLabels[:len(c.continueLabels)-1]

	if c.peek().Type != TOKEN_END {
		return fmt.Errorf("line %d: expected 'end' to close while loop", c.peek().Line)
	}
	c.advance()

	c.writeIndent()
	c.output.WriteString("end\n")

	return nil
}

func (c *Compiler) forStatement() error {
	c.advance() // consume 'for'

	c.labelCounter++
	label := c.labelCounter
	c.continueLabels = append(c.continueLabels, label)
	c.loopDepth++

	c.writeIndent()
	c.output.WriteString("for ")

	c.pushScope()

	if c.peek().Type != TOKEN_IDENT {
		return fmt.Errorf("line %d: expected identifier in for loop", c.peek().Line)
	}

	firstName := c.advance().Value
	c.output.WriteString(firstName)
	c.declareVariable(firstName)

	if c.peek().Type == TOKEN_COMMA {
		// for k, v in ... (generic for)
		c.advance()
		c.output.WriteString(", ")

		for {
			if c.peek().Type != TOKEN_IDENT {
				return fmt.Errorf("line %d: expected identifier", c.peek().Line)
			}
			name := c.advance().Value
			c.output.WriteString(name)
			c.declareVariable(name)

			if c.peek().Type != TOKEN_COMMA {
				break
			}
			c.advance()
			c.output.WriteString(", ")
		}

		if c.peek().Type != TOKEN_IN {
			return fmt.Errorf("line %d: expected 'in' in for loop", c.peek().Line)
		}
		c.advance()
		c.output.WriteString(" in ")

		if err := c.expressionList(); err != nil {
			return err
		}
	} else if c.peek().Type == TOKEN_IN {
		// for v in ... (generic for with single var)
		c.advance()
		c.output.WriteString(" in ")

		if err := c.expressionList(); err != nil {
			return err
		}
	} else if c.peek().Type == TOKEN_ASSIGN {
		// for i = start, end [, step] (numeric for)
		c.advance()
		c.output.WriteString(" = ")

		if err := c.expression(); err != nil {
			return err
		}

		if c.peek().Type != TOKEN_COMMA {
			return fmt.Errorf("line %d: expected ',' in numeric for loop", c.peek().Line)
		}
		c.advance()
		c.output.WriteString(", ")

		if err := c.expression(); err != nil {
			return err
		}

		if c.peek().Type == TOKEN_COMMA {
			c.advance()
			c.output.WriteString(", ")
			if err := c.expression(); err != nil {
				return err
			}
		}
	} else {
		return fmt.Errorf("line %d: invalid for loop syntax", c.peek().Line)
	}

	if c.peek().Type != TOKEN_DO {
		return fmt.Errorf("line %d: expected 'do' in for loop", c.peek().Line)
	}
	c.advance()
	c.output.WriteString(" do\n")

	c.indent++

	for c.peek().Type != TOKEN_END && !c.isAtEnd() {
		if err := c.statement(); err != nil {
			return err
		}
	}

	// Add continue label before end
	c.writeIndent()
	c.output.WriteString(fmt.Sprintf("::__continue_%d__::\n", label))

	c.indent--
	c.popScope()
	c.loopDepth--
	c.continueLabels = c.continueLabels[:len(c.continueLabels)-1]

	if c.peek().Type != TOKEN_END {
		return fmt.Errorf("line %d: expected 'end' to close for loop", c.peek().Line)
	}
	c.advance()

	c.writeIndent()
	c.output.WriteString("end\n")

	return nil
}

func (c *Compiler) repeatStatement() error {
	c.advance() // consume 'repeat'

	c.labelCounter++
	label := c.labelCounter
	c.continueLabels = append(c.continueLabels, label)
	c.loopDepth++

	c.writeIndent()
	c.output.WriteString("repeat\n")

	c.indent++
	c.pushScope()

	for c.peek().Type != TOKEN_UNTIL && !c.isAtEnd() {
		if err := c.statement(); err != nil {
			return err
		}
	}

	// Add continue label before until
	c.writeIndent()
	c.output.WriteString(fmt.Sprintf("::__continue_%d__::\n", label))

	c.popScope()
	c.indent--
	c.loopDepth--
	c.continueLabels = c.continueLabels[:len(c.continueLabels)-1]

	if c.peek().Type != TOKEN_UNTIL {
		return fmt.Errorf("line %d: expected 'until' to close repeat loop", c.peek().Line)
	}
	c.advance()

	c.writeIndent()
	c.output.WriteString("until ")

	if err := c.expression(); err != nil {
		return err
	}
	c.output.WriteString("\n")

	return nil
}

func (c *Compiler) doStatement() error {
	c.advance() // consume 'do'

	c.writeIndent()
	c.output.WriteString("do\n")

	c.indent++
	c.pushScope()

	for c.peek().Type != TOKEN_END && !c.isAtEnd() {
		if err := c.statement(); err != nil {
			return err
		}
	}

	c.popScope()
	c.indent--

	if c.peek().Type != TOKEN_END {
		return fmt.Errorf("line %d: expected 'end' to close do block", c.peek().Line)
	}
	c.advance()

	c.writeIndent()
	c.output.WriteString("end\n")

	return nil
}

func (c *Compiler) returnStatement() error {
	c.advance() // consume 'return'

	c.writeIndent()
	c.output.WriteString("return")

	// Check if there's an expression to return
	if !c.isStatementEnd() {
		c.output.WriteString(" ")
		if err := c.expressionList(); err != nil {
			return err
		}
	}
	c.output.WriteString("\n")

	return nil
}

func (c *Compiler) breakStatement() error {
	c.advance() // consume 'break'

	c.writeIndent()
	c.output.WriteString("break\n")

	return nil
}

func (c *Compiler) continueStatement() error {
	c.advance() // consume 'continue'

	if c.loopDepth == 0 {
		return fmt.Errorf("line %d: 'continue' outside of loop", c.peek().Line)
	}

	label := c.continueLabels[len(c.continueLabels)-1]
	c.writeIndent()
	c.output.WriteString(fmt.Sprintf("goto __continue_%d__\n", label))

	return nil
}

func (c *Compiler) gotoStatement() error {
	c.advance() // consume 'goto'

	if c.peek().Type != TOKEN_IDENT {
		return fmt.Errorf("line %d: expected label name after 'goto'", c.peek().Line)
	}

	name := c.advance().Value
	c.writeIndent()
	c.output.WriteString("goto ")
	c.output.WriteString(name)
	c.output.WriteString("\n")

	return nil
}

func (c *Compiler) labelStatement() error {
	c.advance() // consume '::'

	if c.peek().Type != TOKEN_IDENT {
		return fmt.Errorf("line %d: expected label name", c.peek().Line)
	}

	name := c.advance().Value

	if c.peek().Type != TOKEN_DOUBLECOLON {
		return fmt.Errorf("line %d: expected '::' after label name", c.peek().Line)
	}
	c.advance()

	c.writeIndent()
	c.output.WriteString("::")
	c.output.WriteString(name)
	c.output.WriteString("::\n")

	return nil
}

func (c *Compiler) switchStatement() error {
	c.advance() // consume 'switch'

	c.switchDepth++

	// Capture the switch expression by temporarily redirecting output
	savedOutput := c.output.String()
	c.output.Reset()
	if err := c.expression(); err != nil {
		return err
	}
	switchExprStr := c.output.String()
	c.output.Reset()
	c.output.WriteString(savedOutput)

	// Generate a temp variable to hold the switch value
	c.labelCounter++
	tempVar := fmt.Sprintf("__switch_%d__", c.labelCounter)

	c.writeIndent()
	c.output.WriteString("local ")
	c.output.WriteString(tempVar)
	c.output.WriteString(" = ")
	c.output.WriteString(switchExprStr)
	c.output.WriteString("\n")

	// Parse cases
	firstCase := true
	for c.peek().Type == TOKEN_CASE || c.peek().Type == TOKEN_DEFAULT {
		if c.peek().Type == TOKEN_CASE {
			c.advance() // consume 'case'

			c.writeIndent()
			if firstCase {
				c.output.WriteString("if ")
				firstCase = false
			} else {
				c.output.WriteString("elseif ")
			}

			// Handle multiple case values: case "a", "b":
			// Disable method calls while parsing case expressions
			c.noMethodCalls = true
			c.output.WriteString(tempVar)
			c.output.WriteString(" == ")
			if err := c.expression(); err != nil {
				c.noMethodCalls = false
				return err
			}

			for c.peek().Type == TOKEN_COMMA {
				c.advance()
				c.output.WriteString(" or ")
				c.output.WriteString(tempVar)
				c.output.WriteString(" == ")
				if err := c.expression(); err != nil {
					c.noMethodCalls = false
					return err
				}
			}
			c.noMethodCalls = false

			if c.peek().Type != TOKEN_COLON {
				return fmt.Errorf("line %d: expected ':' after case value", c.peek().Line)
			}
			c.advance()

			c.output.WriteString(" then\n")

			c.indent++
			c.pushScope()

			// Parse case body
			for c.peek().Type != TOKEN_CASE && c.peek().Type != TOKEN_DEFAULT && c.peek().Type != TOKEN_END && !c.isAtEnd() {
				if err := c.statement(); err != nil {
					return err
				}
			}

			c.popScope()
			c.indent--

		} else if c.peek().Type == TOKEN_DEFAULT {
			c.advance() // consume 'default'

			if c.peek().Type != TOKEN_COLON {
				return fmt.Errorf("line %d: expected ':' after 'default'", c.peek().Line)
			}
			c.advance()

			c.writeIndent()
			if firstCase {
				c.output.WriteString("do\n")
			} else {
				c.output.WriteString("else\n")
			}

			c.indent++
			c.pushScope()

			// Parse default body
			for c.peek().Type != TOKEN_END && !c.isAtEnd() {
				if err := c.statement(); err != nil {
					return err
				}
			}

			c.popScope()
			c.indent--
		}
	}

	if c.peek().Type != TOKEN_END {
		return fmt.Errorf("line %d: expected 'end' to close switch statement", c.peek().Line)
	}
	c.advance()

	c.writeIndent()
	c.output.WriteString("end\n")

	c.switchDepth--

	return nil
}

func (c *Compiler) expressionStatement() error {
	// This could be an assignment or a function call
	// We need to parse the left side first, then check for assignment

	savedOutput := c.output.String()
	c.output.Reset()

	if err := c.primaryExpression(); err != nil {
		return err
	}

	leftStr := c.output.String()
	c.output.Reset()
	c.output.WriteString(savedOutput)

	// Check for compound assignment
	compoundOps := map[TokenType]string{
		TOKEN_PLUS_ASSIGN:    " + ",
		TOKEN_MINUS_ASSIGN:   " - ",
		TOKEN_STAR_ASSIGN:    " * ",
		TOKEN_SLASH_ASSIGN:   " / ",
		TOKEN_PERCENT_ASSIGN: " % ",
		TOKEN_DOTDOT_ASSIGN:  " .. ",
	}

	if op, ok := compoundOps[c.peek().Type]; ok {
		c.advance() // consume compound operator

		// Check if this is a new variable
		isNewVar := c.isNewVariable(leftStr)

		c.writeIndent()
		if isNewVar {
			c.output.WriteString("local ")
			c.declareVariable(leftStr)
		}
		c.output.WriteString(leftStr)
		c.output.WriteString(" = ")
		c.output.WriteString(leftStr)
		c.output.WriteString(op)

		if err := c.expression(); err != nil {
			return err
		}
		c.output.WriteString("\n")
		return nil
	}

	// Check for regular assignment
	if c.peek().Type == TOKEN_ASSIGN {
		c.advance() // consume '='

		// Check if this is a new variable (simple identifier)
		isNewVar := c.isNewVariable(leftStr)

		c.writeIndent()
		if isNewVar && !strings.Contains(leftStr, ".") && !strings.Contains(leftStr, "[") {
			c.output.WriteString("local ")
			c.declareVariable(leftStr)
		}
		c.output.WriteString(leftStr)
		c.output.WriteString(" = ")

		if err := c.expression(); err != nil {
			return err
		}
		c.output.WriteString("\n")
		return nil
	}

	// Check for multiple assignment: a, b = 1, 2
	if c.peek().Type == TOKEN_COMMA {
		vars := []string{leftStr}
		newVars := []string{}
		if c.isNewVariable(leftStr) {
			newVars = append(newVars, leftStr)
		}

		for c.peek().Type == TOKEN_COMMA {
			c.advance() // consume ','

			// Capture next variable using save/restore
			savedOut := c.output.String()
			c.output.Reset()
			if err := c.primaryExpression(); err != nil {
				return err
			}
			varName := c.output.String()
			c.output.Reset()
			c.output.WriteString(savedOut)

			vars = append(vars, varName)
			if c.isNewVariable(varName) && !strings.Contains(varName, ".") && !strings.Contains(varName, "[") {
				newVars = append(newVars, varName)
			}
		}

		if c.peek().Type != TOKEN_ASSIGN {
			return fmt.Errorf("line %d: expected '=' in assignment", c.peek().Line)
		}
		c.advance()

		// Declare new variables
		for _, v := range newVars {
			c.declareVariable(v)
		}

		c.writeIndent()
		if len(newVars) > 0 {
			c.output.WriteString("local ")
		}
		c.output.WriteString(strings.Join(vars, ", "))
		c.output.WriteString(" = ")

		if err := c.expressionList(); err != nil {
			return err
		}
		c.output.WriteString("\n")
		return nil
	}

	// It's just an expression (probably a function call)
	c.writeIndent()
	c.output.WriteString(leftStr)
	c.output.WriteString("\n")

	return nil
}

func (c *Compiler) expression() error {
	return c.nullCoalesce()
}

func (c *Compiler) nullCoalesce() error {
	// Capture left side using save/restore pattern
	savedOutput := c.output.String()
	c.output.Reset()

	if err := c.logicalOr(); err != nil {
		return err
	}

	leftStr := c.output.String()
	c.output.Reset()
	c.output.WriteString(savedOutput)

	if c.peek().Type == TOKEN_DOUBLE_QUESTION {
		c.advance() // consume '??'

		// Generate: (function() local __t = left; if __t ~= nil then return __t else return right end end)()
		c.labelCounter++
		tempVar := fmt.Sprintf("__nc_%d__", c.labelCounter)

		c.output.WriteString("(function() local ")
		c.output.WriteString(tempVar)
		c.output.WriteString(" = ")
		c.output.WriteString(leftStr)
		c.output.WriteString("; if ")
		c.output.WriteString(tempVar)
		c.output.WriteString(" ~= nil then return ")
		c.output.WriteString(tempVar)
		c.output.WriteString(" else return ")

		if err := c.nullCoalesce(); err != nil {
			return err
		}

		c.output.WriteString(" end end)()")
	} else {
		c.output.WriteString(leftStr)
	}

	return nil
}

func (c *Compiler) logicalOr() error {
	if err := c.logicalAnd(); err != nil {
		return err
	}

	for c.peek().Type == TOKEN_OR {
		c.advance()
		c.output.WriteString(" or ")
		if err := c.logicalAnd(); err != nil {
			return err
		}
	}

	return nil
}

func (c *Compiler) logicalAnd() error {
	if err := c.comparison(); err != nil {
		return err
	}

	for c.peek().Type == TOKEN_AND {
		c.advance()
		c.output.WriteString(" and ")
		if err := c.comparison(); err != nil {
			return err
		}
	}

	return nil
}

func (c *Compiler) comparison() error {
	if err := c.concatenation(); err != nil {
		return err
	}

	for {
		switch c.peek().Type {
		case TOKEN_LT:
			c.advance()
			c.output.WriteString(" < ")
		case TOKEN_GT:
			c.advance()
			c.output.WriteString(" > ")
		case TOKEN_LE:
			c.advance()
			c.output.WriteString(" <= ")
		case TOKEN_GE:
			c.advance()
			c.output.WriteString(" >= ")
		case TOKEN_EQ:
			c.advance()
			c.output.WriteString(" == ")
		case TOKEN_NEQ:
			c.advance()
			c.output.WriteString(" ~= ")
		default:
			return nil
		}

		if err := c.concatenation(); err != nil {
			return err
		}
	}
}

func (c *Compiler) concatenation() error {
	if err := c.addition(); err != nil {
		return err
	}

	for c.peek().Type == TOKEN_DOTDOT {
		c.advance()
		c.output.WriteString(" .. ")
		if err := c.addition(); err != nil {
			return err
		}
	}

	return nil
}

func (c *Compiler) addition() error {
	if err := c.multiplication(); err != nil {
		return err
	}

	for {
		switch c.peek().Type {
		case TOKEN_PLUS:
			c.advance()
			c.output.WriteString(" + ")
		case TOKEN_MINUS:
			c.advance()
			c.output.WriteString(" - ")
		default:
			return nil
		}

		if err := c.multiplication(); err != nil {
			return err
		}
	}
}

func (c *Compiler) multiplication() error {
	if err := c.unary(); err != nil {
		return err
	}

	for {
		switch c.peek().Type {
		case TOKEN_STAR:
			c.advance()
			c.output.WriteString(" * ")
		case TOKEN_SLASH:
			c.advance()
			c.output.WriteString(" / ")
		case TOKEN_PERCENT:
			c.advance()
			c.output.WriteString(" % ")
		default:
			return nil
		}

		if err := c.unary(); err != nil {
			return err
		}
	}
}

func (c *Compiler) unary() error {
	switch c.peek().Type {
	case TOKEN_NOT:
		c.advance()
		c.output.WriteString("not ")
		return c.unary()
	case TOKEN_MINUS:
		c.advance()
		c.output.WriteString("-")
		return c.unary()
	case TOKEN_HASH:
		c.advance()
		c.output.WriteString("#")
		return c.unary()
	}

	return c.power()
}

func (c *Compiler) power() error {
	if err := c.primaryExpression(); err != nil {
		return err
	}

	if c.peek().Type == TOKEN_CARET {
		c.advance()
		c.output.WriteString(" ^ ")
		if err := c.unary(); err != nil {
			return err
		}
	}

	return nil
}

func (c *Compiler) primaryExpression() error {
	if err := c.atom(); err != nil {
		return err
	}

	// Handle suffixes: calls, indexing, field access, optional chaining
	for {
		switch c.peek().Type {
		case TOKEN_DOT:
			c.advance()
			c.output.WriteString(".")
			if c.peek().Type != TOKEN_IDENT {
				return fmt.Errorf("line %d: expected identifier after '.'", c.peek().Line)
			}
			c.output.WriteString(c.advance().Value)

		case TOKEN_QUESTION_DOT:
			// Optional chaining: obj?.field
			c.advance()

			// We need to wrap the current expression
			// This is tricky - we'll generate a function that checks nil
			c.labelCounter++
			tempVar := fmt.Sprintf("__oc_%d__", c.labelCounter)

			// Get what we've built so far
			currentExpr := c.output.String()
			c.output.Reset()

			c.output.WriteString("(function() local ")
			c.output.WriteString(tempVar)
			c.output.WriteString(" = ")
			c.output.WriteString(currentExpr)
			c.output.WriteString("; if ")
			c.output.WriteString(tempVar)
			c.output.WriteString(" == nil then return nil end; return ")
			c.output.WriteString(tempVar)
			c.output.WriteString(".")

			if c.peek().Type != TOKEN_IDENT {
				return fmt.Errorf("line %d: expected identifier after '?.'", c.peek().Line)
			}
			c.output.WriteString(c.advance().Value)
			c.output.WriteString(" end)()")

		case TOKEN_LBRACKET:
			c.advance()

			// Determine if this is numeric indexing
			// If the index is a string literal, don't offset
			// Otherwise, offset by 1
			savedOut := c.output.String()
			c.output.Reset()

			startToken := c.peek()
			if err := c.expression(); err != nil {
				return err
			}

			indexStr := c.output.String()
			c.output.Reset()
			c.output.WriteString(savedOut)

			// Check if it's a string literal (don't offset) or numeric (offset by 1)
			isStringLiteral := startToken.Type == TOKEN_STRING

			c.output.WriteString("[")
			if isStringLiteral {
				c.output.WriteString(indexStr)
			} else {
				c.output.WriteString("(")
				c.output.WriteString(indexStr)
				c.output.WriteString(") + 1")
			}
			c.output.WriteString("]")

			if c.peek().Type != TOKEN_RBRACKET {
				return fmt.Errorf("line %d: expected ']'", c.peek().Line)
			}
			c.advance()

		case TOKEN_COLON:
			// Only treat as method call if followed by identifier and method calls are enabled
			if c.noMethodCalls || c.peekNext().Type != TOKEN_IDENT {
				return nil
			}
			c.advance()
			c.output.WriteString(":")
			c.output.WriteString(c.advance().Value)

			// Method call must be followed by arguments
			if c.peek().Type != TOKEN_LPAREN && c.peek().Type != TOKEN_STRING && c.peek().Type != TOKEN_LBRACE {
				return fmt.Errorf("line %d: expected arguments after method name", c.peek().Line)
			}
			if err := c.callArguments(); err != nil {
				return err
			}

		case TOKEN_LPAREN:
			if err := c.callArguments(); err != nil {
				return err
			}

		case TOKEN_STRING:
			// Function call with string argument: print "hello"
			c.output.WriteString("(")
			c.output.WriteString(c.advance().Value)
			c.output.WriteString(")")

		case TOKEN_LBRACE:
			// Function call with table argument: func{...}
			if err := c.tableConstructor(); err != nil {
				return err
			}

		default:
			return nil
		}
	}
}

func (c *Compiler) callArguments() error {
	if c.peek().Type != TOKEN_LPAREN {
		return nil
	}
	c.advance()
	c.output.WriteString("(")

	if c.peek().Type != TOKEN_RPAREN {
		if err := c.expressionList(); err != nil {
			return err
		}
	}

	if c.peek().Type != TOKEN_RPAREN {
		return fmt.Errorf("line %d: expected ')' after arguments", c.peek().Line)
	}
	c.advance()
	c.output.WriteString(")")

	return nil
}

func (c *Compiler) atom() error {
	switch c.peek().Type {
	case TOKEN_NIL:
		c.advance()
		c.output.WriteString("nil")

	case TOKEN_TRUE:
		c.advance()
		c.output.WriteString("true")

	case TOKEN_FALSE:
		c.advance()
		c.output.WriteString("false")

	case TOKEN_NUMBER:
		numStr := c.advance().Value
		converted, err := ConvertNumber(numStr)
		if err != nil {
			return err
		}
		c.output.WriteString(converted)

	case TOKEN_STRING:
		c.output.WriteString(c.advance().Value)

	case TOKEN_TEMPLATE_STRING:
		if err := c.compileTemplateString(c.advance().Value); err != nil {
			return err
		}

	case TOKEN_IDENT:
		c.output.WriteString(c.advance().Value)

	case TOKEN_DOTDOTDOT:
		c.advance()
		c.output.WriteString("...")

	case TOKEN_LPAREN:
		c.advance()
		c.output.WriteString("(")
		if err := c.expression(); err != nil {
			return err
		}
		if c.peek().Type != TOKEN_RPAREN {
			return fmt.Errorf("line %d: expected ')'", c.peek().Line)
		}
		c.advance()
		c.output.WriteString(")")

	case TOKEN_LBRACE:
		if err := c.tableConstructor(); err != nil {
			return err
		}

	case TOKEN_FUNCTION:
		c.advance()
		c.output.WriteString("function")
		if err := c.functionBody(); err != nil {
			return err
		}
		// Remove the trailing newline that functionBody adds
		str := c.output.String()
		if strings.HasSuffix(str, "\n") {
			c.output.Reset()
			c.output.WriteString(strings.TrimSuffix(str, "\n"))
		}

	default:
		return fmt.Errorf("line %d: unexpected token %v", c.peek().Line, c.peek().Value)
	}

	return nil
}

func (c *Compiler) tableConstructor() error {
	c.advance() // consume '{'
	c.output.WriteString("{")

	first := true
	index := 0

	for c.peek().Type != TOKEN_RBRACE && !c.isAtEnd() {
		if !first {
			c.output.WriteString(", ")
		}
		first = false

		// Check for [expr] = value syntax
		if c.peek().Type == TOKEN_LBRACKET {
			c.advance()

			// Check if it's a numeric index that needs offsetting
			startToken := c.peek()
			savedOut := c.output.String()
			c.output.Reset()

			if err := c.expression(); err != nil {
				return err
			}

			indexStr := c.output.String()
			c.output.Reset()
			c.output.WriteString(savedOut)
			c.output.WriteString("[")

			isStringLiteral := startToken.Type == TOKEN_STRING

			if isStringLiteral {
				c.output.WriteString(indexStr)
			} else {
				c.output.WriteString("(")
				c.output.WriteString(indexStr)
				c.output.WriteString(") + 1")
			}

			c.output.WriteString("]")

			if c.peek().Type != TOKEN_RBRACKET {
				return fmt.Errorf("line %d: expected ']' in table constructor", c.peek().Line)
			}
			c.advance()

			if c.peek().Type != TOKEN_ASSIGN {
				return fmt.Errorf("line %d: expected '=' after table key", c.peek().Line)
			}
			c.advance()
			c.output.WriteString(" = ")

			if err := c.expression(); err != nil {
				return err
			}
		} else if c.peek().Type == TOKEN_IDENT && c.peekNext().Type == TOKEN_ASSIGN {
			// name = value syntax
			c.output.WriteString(c.advance().Value)
			c.advance() // consume '='
			c.output.WriteString(" = ")
			if err := c.expression(); err != nil {
				return err
			}
		} else {
			// Array element - these are 0-indexed in tokimun
			// So we need to store them with explicit indices
			// t[0] in tokimun = t[1] in Lua
			c.output.WriteString(fmt.Sprintf("[%d] = ", index+1))
			if err := c.expression(); err != nil {
				return err
			}
			index++
		}

		// Optional comma or semicolon
		if c.peek().Type == TOKEN_COMMA || c.peek().Type == TOKEN_SEMICOLON {
			c.advance()
		}
	}

	if c.peek().Type != TOKEN_RBRACE {
		return fmt.Errorf("line %d: expected '}' to close table", c.peek().Line)
	}
	c.advance()
	c.output.WriteString("}")

	return nil
}

func (c *Compiler) expressionList() error {
	if err := c.expression(); err != nil {
		return err
	}

	for c.peek().Type == TOKEN_COMMA {
		c.advance()
		c.output.WriteString(", ")
		if err := c.expression(); err != nil {
			return err
		}
	}

	return nil
}

func (c *Compiler) compileTemplateString(template string) error {
	// Remove backticks
	template = template[1 : len(template)-1]

	// Parse and compile template string with ${...} interpolations
	var result strings.Builder
	result.WriteString("(")

	parts := []string{}
	current := ""
	i := 0

	for i < len(template) {
		if i+1 < len(template) && template[i] == '$' && template[i+1] == '{' {
			// Found interpolation
			if current != "" {
				parts = append(parts, fmt.Sprintf("%q", current))
				current = ""
			}

			// Find matching }
			i += 2 // skip ${
			braceDepth := 1
			exprStart := i

			for i < len(template) && braceDepth > 0 {
				if template[i] == '{' {
					braceDepth++
				} else if template[i] == '}' {
					braceDepth--
				}
				if braceDepth > 0 {
					i++
				}
			}

			expr := template[exprStart:i]
			i++ // skip closing }

			// Compile the expression using a fresh compiler
			lexer := NewLexer(expr)
			tokens, err := lexer.Tokenize()
			if err != nil {
				return fmt.Errorf("in template string: %v", err)
			}

			compiler := NewCompiler(tokens)
			compiler.scopes = c.scopes // Share scope

			if err := compiler.expression(); err != nil {
				return fmt.Errorf("in template string: %v", err)
			}

			parts = append(parts, fmt.Sprintf("tostring(%s)", compiler.output.String()))
		} else if template[i] == '\\' && i+1 < len(template) {
			// Handle escape sequences
			i++
			switch template[i] {
			case 'n':
				current += "\n"
			case 't':
				current += "\t"
			case 'r':
				current += "\r"
			case '\\':
				current += "\\"
			case '$':
				current += "$"
			case '`':
				current += "`"
			default:
				current += string(template[i])
			}
			i++
		} else {
			current += string(template[i])
			i++
		}
	}

	if current != "" {
		parts = append(parts, fmt.Sprintf("%q", current))
	}

	if len(parts) == 0 {
		result.WriteString(`""`)
	} else {
		result.WriteString(strings.Join(parts, " .. "))
	}

	result.WriteString(")")
	c.output.WriteString(result.String())

	return nil
}

// Helper methods
func (c *Compiler) peek() Token {
	if c.current >= len(c.tokens) {
		return Token{Type: TOKEN_EOF}
	}
	return c.tokens[c.current]
}

func (c *Compiler) peekNext() Token {
	if c.current+1 >= len(c.tokens) {
		return Token{Type: TOKEN_EOF}
	}
	return c.tokens[c.current+1]
}

func (c *Compiler) advance() Token {
	if !c.isAtEnd() {
		c.current++
	}
	return c.tokens[c.current-1]
}

func (c *Compiler) isAtEnd() bool {
	return c.peek().Type == TOKEN_EOF
}

func (c *Compiler) writeIndent() {
	for i := 0; i < c.indent; i++ {
		c.output.WriteString("  ")
	}
}

func (c *Compiler) pushScope() {
	c.scopes = append(c.scopes, make(map[string]bool))
}

func (c *Compiler) popScope() {
	if len(c.scopes) > 1 {
		c.scopes = c.scopes[:len(c.scopes)-1]
	}
}

func (c *Compiler) declareVariable(name string) {
	if len(c.scopes) > 0 {
		c.scopes[len(c.scopes)-1][name] = true
	}
}

func (c *Compiler) isVariableDeclared(name string) bool {
	for i := len(c.scopes) - 1; i >= 0; i-- {
		if c.scopes[i][name] {
			return true
		}
	}
	return false
}

func (c *Compiler) isNewVariable(name string) bool {
	// Check if name is a simple identifier (not a table access)
	matched, _ := regexp.MatchString(`^[a-zA-Z_][a-zA-Z0-9_]*$`, name)
	if !matched {
		return false
	}
	return !c.isVariableDeclared(name)
}

func (c *Compiler) isStatementEnd() bool {
	switch c.peek().Type {
	case TOKEN_EOF, TOKEN_END, TOKEN_ELSE, TOKEN_ELSEIF, TOKEN_UNTIL, TOKEN_CASE, TOKEN_DEFAULT:
		return true
	}
	// Check if next token could start a new statement
	switch c.peek().Type {
	case TOKEN_IF, TOKEN_WHILE, TOKEN_FOR, TOKEN_REPEAT, TOKEN_DO, TOKEN_FUNCTION,
		TOKEN_LOCAL, TOKEN_GLOBAL, TOKEN_RETURN, TOKEN_BREAK, TOKEN_CONTINUE, TOKEN_GOTO:
		return true
	}
	return false
}
